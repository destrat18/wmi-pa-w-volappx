===
WMI
===
Introduction
------------

**Weighted model integration** (WMI) is a recent formalism generalizing **weighted model counting** (WMC) to run probabilistic inference over hybrid domains, characterized by both discrete and continuous variables and relationships between them.

WMC is the task of computing the weighted sum of all satisfying assignments of a propositional formula, where weights are associated to models and are typically factorized into the product of weights of individual variables.

An inherent limitation of WMC is that it can only deal with discrete distributions. In order to overcome this restriction, WMI was recently introduced as a formulation generalizing WMC to deal with hybrid domains. The formalism relies on **satisfiability modulo theories** (SMT) technology, which allows to reason about the satisfiability of formulas involving e.g. linear constraints over integers or reals (although this implementation currently accepts only reals). WMI works by replacing the weighted sum of models of a propositional formula with a sum of integrals over weight functions defined over the models of an SMT formula. Weight functions here play the role of (unnormalized) densities, whereas logic formulas in the model define the integration domain.

Requirements
------------
In order to use WMI you will need the following software installed on your machine:

* `Sympy <http://www.sympy.org/en/index.html>`_
* `NetworkX <https://networkx.github.io/>`_
* `Matplotlib <https://matplotlib.org/>`_
* `Latte Integrale <https://www.math.ucdavis.edu/~latte/>`_
* `pysmt and MathSAT5 <https://github.com/pysmt/pysmt>`_

Click on every link and follow the instructions in order to install every one of them. 
Note that WMI requires at least **python3**.

Once you have finished installing you can continue this tutorial.

How to use it
-------------
**WMI-PA** can be both imported and used inside a python script or also used with a **CLI** interface. We will start the tutorial with the script one, but first some terminology.

* **Chi or Support:**
    a formula that rapresent a region where outside this region the WMI is 0. In short words it represents the domain of the variables involved in the computation, e.g:
        ::

            0 < X < 10

* **Weight or Weight Function:**
    a formula that defines the weight of WMI or, in simplier words, the integrand of the integral that will be computed. E.g:
        ::

            if X > 5 then 2 else 1

This two formulas toghether represents the **model** of WMI. There is finally one last part that is:

* **Phi or Query:**
    the query to give to the model in order to compute the WMI. E.g:
        ::

            X > 3

Python
^^^^^^

Importing
"""""""""

First of all you need to import the main component of WMI with the following command:
    ::

        from wmipa import WMI

You will also need pysmt in order to create formulas. To create your first formulas import the following modules:
    ::

        from pysmt.shortcuts import *
        from pysmt.typing import REAL, BOOL

Inside *shortcuts* there are all the logical and mathematical operators like **Or**, **And**, **Plus**, etc.. and also **Symbol** that is used in combination with **REAL** and **BOOL** in order to create your first variables.

Numbers
"""""""

In **pysmt** every component of a formula is of type **FNode**, this means that you cannot use numbers like 5 or 42 like they are, but you need to create an opportune object that contains every number used in the code.
    ::

        n_42 = Real(42)

This command creates a new **FNode** with value 42 and type **Real**. Notice that **pysmt** allow integer types too, but the current version of WMI does not supports operation over integers.

Variables
"""""""""

In order to create formulas you will first need to declare some variables. You can do it with the following command:
    ::

        X = Symbol("X", REAL)

you have now created your first variable, with name **x** and type **Real**. You can also create boolean variables in the same way but specifying **Bool** instead of **Real**:
    ::

        A = Symbol("A", BOOL)

Formula
"""""""

**pysmt** is a language that uses prefix operators like the following one:
    ::

        formula = Plus(X, Real(2), Real(4.5))

this command will create the formula:
    ::

        X + 2 + 4.5

where **X** was the variable created in the previous paragraph, of type **Real**.

To kwow more about **pysmt** operators visit the `official page of pysmt <https://pysmt.readthedocs.io>`_.

WMI Object
""""""""""

Now that you kwno how **pysmt** works we can start by creating your first instantiation of WMI.

Let's start with a simple example. We want to compute WMI with the following parameters:
    ::

        X, REAL
        A, BOOL
        Support = 0 <= X <= 10
        Weight = If A then 2 else 3*X
        Phi = X >= 5

The constructor of this class takes three parameters, one required and two optional:

* support (required):
    As said in `How to use it`_, this is the domain of the variables, and in our case it is:
        ::

            0 <= X <= 10

    and in **pysmt** is written as:
        ::

            x = Symbol("X", REAL)
            support = And(GE(x, Real(0)), LE(x, Real(10)))

    where **GE** and **LE** means respectively **Greater or Equal** and **Less or Equal** (once again visit the `pysmt official page <https://pysmt.readthedocs.io>`_ for furter information on the operators).

    One final note: if there are no restrictions on the variables, the support will just be:
        ::

            support = Bool(True)

* weight (optional):
    If no parameters is passed as weight, than WMI will take the default value, that is 1, so in this case it will compute **MI** (Model Integration). In our example, the weight is:
        ::

            a = Symbol("A", BOOL)
            weight = Ite(a, Real(2), Times(Real(3), x))

    where it stands for **If Then Else**.

* n_threads (optional):
    The number of threads to use when calculating WMI. We are not interested in this parameter so we will not pass it (this means that it will take the default value).

Now that we have the required parameters, we can create the instantiation of WMI with the following command:
    ::

        wmi = WMI(support, weight)

and to use a custom number of threads (e.g. 5) we will create it like this:
    ::

        wmi = WMI(support, weight, n_threads = 5)

We can now compute query on this particular object that we have just initialized with our model.

Computing WMI
"""""""""""""

In order to compute WMI we will use the method
    ::
        
        computeWMI

that takes two parameters:

* query (required):
    The query on which to compute WMI. In our case this will be:
        ::

            query = GE(x, Real(5))

* options (optional):
    A list of optional values, that are:
    
    + mode:
        The mode with which to compute WMI. These are **BC**, **AllSMT** and **PA** and can be used e.g:
            ::

                mode = WMI.MODE_BC
                mode = WMI.MODE_ALLSMT
                mode = WMI.MODE_PA
         
        The default one is **PA** that stands for **Predicate Abstraction** and it's the fastest among the three.

    + domX:
        The domain of integration of the real variables. This must be the same of the set of all the variables contained in the model, in our example this will be {x}.

    + domA:
        The domain of integration of the boolean variables. This can be a superset of the set of all the variables contained in the model. In our example the minimal set is {a} but can also be {a, b, c} where **b** and **c** are two other boolean variables that has to be declared. In this last example the final value of WMI will be multiplied by 2 :sup:`|domA - A|`, where **A** is the set of boolean variables in the model.

We can finally compute WMI with the command:
    ::

        result, n_integrations = wmi.computeWMI(query)

or with another mode:
    ::

        result, n_integrations = wmi.computeWMI(query, mode=WMI.MODE_ALLSMT)

**result** contains the final result of the computation (in our case it is 122.5) while **n_integrations** contains the number of integrations performed by WMI (in our case it is 2).

By testing with differents models, queries and modalities, you will notice that sometimes **MODE_PA** will compute less integrals than the other two and this leads to a faster execution.

Actual computation
""""""""""""""""""

We have seen how to use WMI in a python script and the final result, but for those intereseted in the actual computation, here there are the calculation made by WMI (but for further information look at the `official paper <https://www.ijcai.org/proceedings/2017/100>`_ from where this program comes).

The boolean variable **A** can take both **True** and **False** value so we will compute WMI in both cases.

Let's examine the first case, where **A** is true:
    in this case the **weight** is 2 and the variable **X** can assume values ranging from 5 to 10 (intersection of both **support** and **query**). So the integral is:

.. Actual formula in Latex: \int_{5}^{10} 2\ dx =\ \Bigm|_{5}^{10} 2x = 20 - 10 = 10
.. image:: integral_1.png
    :width: 400px
    :align: center
    :height: 100px
    :alt: integral_1

Let's now examine the other case, where **A** is false:
   in this other case the only thing that changes is the weight, infact now it is 3x. The integral is:

.. Actual formula in Latex: \int_{5}^{10} 3x\ dx =\ \Bigm|_{5}^{10} \frac{3x^{2}}{2} = 150 - \frac{75}{2} = 112.5
.. image:: integral_2.png
    :width: 400px
    :align: center
    :height: 100px
    :alt: integral_2

Summing together both the results we obtain:
    ::

        10 + 112.5 = 122.5

as we expected.

Complete code
"""""""""""""
Following the complete code of the example:

    ::

        # Import
        from wmipa import WMI
        from pysmt.shortcuts import *
        from pysmt.typing import REAL, BOOL
    
        # Variable declaration
        x = Symbol("X", REAL)
        a = Symbol("A", BOOL)
        
        # Support
        support = And(GE(x, Real(0)), LE(x, Real(10)))

        # Weight
        weight = Ite(a, Real(2), Times(Real(3), x))

        # Query
        query = GE(x, Real(5))

        # Instantiate WMI
        wmi = WMI(support, weight)    
        
        # Compute WMI
        result, n_integrations = wmi.computeWMI(query)

        print("Result:", result) # Result: 122.5
        print("Number integrations:", n_integrations) # Number integrations: 2

Command Line Interface
^^^^^^^^^^^^^^^^^^^^^^

WMI-PA comes also with a CLI to compute WMI with models and queries. These are files with one of the following formats: `Minizinc <https://www.minizinc.org/>`_ or `SMT-LIB <http://smtlib.cs.uiowa.edu/>`_

To use the CLI you need to provide a model (.mzn or .smt) and at least one query (.mzn or .smt).

In the model there has to be the declaration of all the variables involved in the computation, the support and the weight function, while in the query file there has to be just the query on which to compute WMI.

We will show how to write the model and the query in both **Minizinc** and **SMT-LIB** using the example presented in the last chapter, that is:
    ::

        X, REAL
        A, BOOL
        Support = 0 <= X <= 10
        Weight = If A then 2 else 3*X
        Phi = X >= 5

Model (.mzn)
""""""""""""""""

First of all we need do declare the variables. This can be done with the following commands:
    ::

        var float:x;
        var bool:a;

We can see that there are three parts that are needed in order to declare a variable:

* **var/par**:
    with the keyword **var** we are saying that the variable can assume different values in its domain (and it's therefore a *variable* in all its meaning). If, instead, the **par** keyword was used, the variable would be constant and called parameter. We can also omit this part and in this case it would be automatically be a parameter (**par**).

* **type**:
    the domain of the variable (or parameter). In the first case we have a float variable (that is, real) and in the second case a boolean one.

* **name**:
    the name of the variable.

Both **x** and **a** can assume all the values in they're domains. We want to limit the range of values of x to be inside 0 and 10. This can be done in two different ways.

The first method consists in adding a **constraint**, that is something that has to be true. The command is:
    ::

        constraint (x >= 0) /\ (x <= 10);

The second method add this information in the declaration of the variable itself, like in the following example:
    ::

        var 0.0..10.0:x;

That is, we can initialize a variable with its range of possible values with the **dot-dot** notation. In the generale case:
    ::

        var M..N:x;

where **M** and **N** are respectively minimum and maximum value of the interval of the domain of the variable **x**;

It is possible to add any number of constraint by adding more line with the **constraint** keyword.

The last thing to add to the model is the **weight function** and this can be done with the following command:
    ::

        weight: if a then 2 else 3*x endif;

The complete code of the **model.mzn** file is:
    ::

        /* Variable declaration */
        var float:x;
        var bool:a;

        % Support
        constraint (x >= 0) /\ (x <= 10);

        % Weight function
        weight: if a then 2 else 3*x endif;

Alternatively:
    ::

        % Variable declaration
        var 0.0..10.0:x;
        var bool:a;

        % Weight function
        weight: if a then 2 else 3*x endif;

(Note that that Minizinc supports single line comments starting with **%** and multi line comments surrounded with **/* */**).

Query (.mzn)
""""""""""""

Now that we have the model we just need to add the information of the query with the **query** command, like in the following example:
    ::

        query (x >= 5);

(Additional info on the syntax of Minizinc can be found on the `official page <https://www.minizinc.org/>`_).

Model (.smt)
""""""""""""

First of all we need to declare the variables. This can be done with the following commands:
    ::

        (declare-fun x() Real)
        (declare-fun a() Bool)

or alternatively:
    ::

        (declare-const x Real)
        (declare-const a Bool)

they're the same.

Next we have to define the support, in our case can be done with:
    ::

        (assert (>= x 0))
        (assert (<= x 10))

or alternatively:
    ::

        (assert (and (>= x 0) (<= x 10)))

The **assert** keyword correspond to the **constraint** one in the minizinc syntax: the formula in it has to be true.

Finally we need to define the weight function and can be done with:
    ::

        (weight (ite a 2 (* 3 x)))

The complete code of the **model.smt** file is:
    ::

        ; Variable declaration
        (declare-const x Real)  ; or (declare-fun x() Real)
        (declare-const a Bool)  ; or (declare-fun a() Bool)

        ; Support
        (assert (>= x 0))
        (assert (<= x 10))
        ; or (assert (and (>= x 0) (<= x 10)))

        ; Weight function
        (weight (ite a 2 (* 3 x)))

(Note that that SMT-LIB supports single line comments starting with **;**).

Query (.smt)
""""""""""""

Now that we have the model we just need to add the information of the query with the **query** command, like in the following example:
    ::

        (query (>= x 5))

(Additional info on the syntax of SMT-LIB can be found on the `official page <http://smtlib.cs.uiowa.edu/>`_).

Putting all together
""""""""""""""""""""

We can now take our files just created and call **wmicli.py** with the following syntax:
    ::

        python3 wmicli.py <path/to/model> <path/to/query>

Remember that both **model** and **query** file must have the **.mzn** or **.smt** extension (the CLI will use the parser based on this).

The first file given as input to the CLI will be readed as the model, every other file as queries files.

An example with two query files:
    ::

        python3 wmicli.py model.mzn query1.mzn query2.smt

In this case it will compute WMI two times, the first one with the **query1.mzn** file and the second one with **query2.smt** file (notice that you can use both **.mzn** and **.smt** in the same command).

It is also possible to write everything in one single file (model + queries) like in the following example:
    ::

        % Variable declaration
        var 0.0..10.0:x;
        var bool:a;

        % Weight function
        weight: if a then 2 else 3*x endif;

        % Queries
        query (x > 5);
        query (x > 7.5);

and executed with:
    ::

        python3 wmicli.py <path/to/file>

and in this case it will compute WMI two times, once for every query.

Summing up, if only one file is passed, than it must contain both model and queries, otherwise the first file will be interpreted as model and the remaining as queries.

Output
""""""

The output of the computation will be printed in the console and will contain just the final result. If you also want the number of integration you can add the **-i** flag, e.g:
    ::

        python3 wmicli.py model.mzn query.mzn -i

And this will print (in our example):
    ::

        122.5, 2

There are three optional parameters to handle the output of the computation, these are:

* **-o <path/to/file>**:
    this option will print the output in the file specified. For example:
        ::

            python3 wmicli.py <model> <query> -o res.txt

    will put the result in the file **res.txt** (and it will create it if needed).

* **-os <suffix>**:
    this option will create many output files as there are queries, and all of them will have the name of the query followed by the suffix specified. For example:
        ::

            python3 wmicli.py <model> sample_query.mzn another_query.smt -os _res

    will create two output files called **sample_query_res.txt** and **another_query_res.txt**.

* **-ol <path/to/file1> <path/to/file2>...**:
    this option takes the same number of files of the queries and will put the result of the computation in the same order. For example:
        ::

            python3 wmicli.py <model> query1.mzn query2.smt -ol res1.txt res2.txt

    will create two files called **res1.txt** and **res2.txt**, the first one will contain the result of **query1.mzn** and the other one the result of **query2.smt**.

Finally you can visualize all these informations with the **-h** flag.
